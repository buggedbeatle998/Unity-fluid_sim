#pragma kernel ray_trace


uint3 res;
float fov;
float3 origin;
uint num_particles;
float smoothing_rad;
float3 sun;
float rad;
float3 bounds;

RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> velocities;
RWBuffer<float> masses;
Buffer<float> densities;
Buffer<uint> part_map;
Buffer<uint> keys;
Buffer<uint> start_i;

RWTexture2D<float4> Result;


bool check(uint x, uint y, uint z, float xpos, float ypos, float zpos, float rad_sqr, uint3 id);
uint hash(uint x, uint y, uint z, uint table_size);
uint mod(uint num, uint denom);


[numthreads(32, 32, 1)]
void ray_trace(uint3 id : SV_DispatchThreadID) {
    float rad_sqr = rad * rad;
    Result[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
    float rad_fov = radians(fov);
    float horz = sin(rad_fov) * (int)(id.x - ((res.x >> 1) + 1)) / res.x;
    float vert = sin(rad_fov * res.y / res.x) * (int)(id.y - ((res.y >> 1) + 1)) / res.y;
    float3 start = float3(horz, vert, 1.0) * rsqrt(horz * horz + vert * vert + 1);

    // float xpos = origin.x - horz * origin.z;
    // float ypos = origin.y - vert * origin.z;
    // float zpos = smoothing_rad / 2;
    // int x = (int)(xpos / smoothing_rad);
    // int y = (int)(ypos / smoothing_rad);
    // int z = (int)(zpos / smoothing_rad);
    // int3 sres = int3((int)(res.x / smoothing_rad), (int)(res.y / smoothing_rad), (int)(res.z / smoothing_rad));

    
    // for (uint i = 0; i < num_particles; i++) {
    //     float3 postion = positions[i];
    //     float3 diff = origin - postion;
    //     float mid = dot(diff, start);
    //     float discrim = mid * mid + (rad * rad - dot(diff, diff));
    //     if (discrim > 0) {
    //         Result[id.xy] = float4(1.0, 1.0, 1.0, 1.0);
    //     }
    //     //     float3 intersect = origin + start * -(mid + sqrt(discrim));
    //     //     if (dot(intersect - origin, start) < 0) {
    //     //         continue;
    //     //     }
    //     //     float colour = 1.0 - abs(particles[i].velocity) / 4.0;
    //     //     Result[id.xy] = float4(1.0, colour, colour, 1.0);
    //     //     break;
    //     // }
    //     // float diffx = postion.x - xpos;
    //     // float diffy = postion.y - ypos;
    //     // if (diffx * diffx + diffy * diffy < rad_sqr) {
    //     //     Result[id.xy] = float4(1.0, 0.0, 0.0, 1.0);
    //     // }
    // }
    // uint reps = (uint)(sqrt(bounds.x * bounds.x + bounds.y * bounds.y + bounds.z * bounds.z) + sqrt(origin.x * origin.x + origin.y * origin.y + origin.z * origin.z)) / smoothing_rad;
    // float3 point = origin;
    // while (uint n = 0; n < reps; n++) {
    //     point += start;
    //     if (point.x < 0 || point.y < 0 || point.z < 0 || point.x > bounds.x || point.y > bounds.y || point.z > bounds.z) {
    //         continue;
    //     }
        
    // }

    float min_dist = -1.0;
    for (uint i = 0; i < num_particles; i++) {
        float3 postion = positions[i];
        float3 diff = origin - postion;
        // if (min_dist != -1.0 && (diff.z > min_dist || diff.x > min_dist || diff.y > min_dist)) {
        //     continue;
        // }
        float mid = dot(diff, start);
        float discrim = mid * mid + (rad_sqr - dot(diff, diff));
        if (discrim > 0) {
            float dist = -(mid + sqrt(discrim));
            if (min_dist != -1.0 && dist > min_dist) {
                continue;
            }
            float3 intersect = start * dist;
            if (dot(intersect, start) < 0) {
                continue;
            }
            min_dist = dist;
            float3 normal = intersect + diff;
            normal *= rsqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
            Result[id.xy] = float4(0.0, 0.0, 1.0, 1.0) * (dot(sun, normal) + 1) / 2;
        }
    }

    // for (int b = 0; b < sres.z; b++) {
    //     zpos += smoothing_rad;
    //     for (int m = x - 1; m < x + 2; m++) {
    //         for (int n = y - 1; n < y + 2; n++) {
    //             if (m >= 0 && n >= 0 && m < sres.x && n < sres.y) {
    //                 if(check((uint)m, (uint)n, (uint)b, start, rad_sqr, sun)) return;
    //             }
    //         }
    //     }
    // }
}


// bool check(uint x, uint y, uint z, float3 start, float rad_sqr, float3 sun) {
//     uint key = hash(x, y, z, num_particles);

//     for (uint i = start_i[key]; i < num_particles && keys[i] == key; i++) {
//         float3 postion = positions[part_map[i]];
//         float3 diff = origin - postion;
//         float mid = dot(diff, start);
//         float discrim = mid * mid + (rad_sqr - dot(diff, diff));
//         if (discrim > 0 && dot(intersect - origin, start) > 0) {
//             Result[id.xy] = float4(0.0, 0.0, 1.0, 1.0);
//             float3 intersect = origin + start * -(mid + sqrt(discrim));
//             float3 normal = intersect - postion;
//             Result[id.xy] *= (dot(sun, normal) + 1 ) / 2;
//             break;
//         }
//     }

//     return false;
// }


uint hash(uint x, uint y, uint z, uint table_size) {
    const uint xhash = 73856093;
    const uint yhash = 19349663;
    const uint zhash = 83492791;
    return mod((x * xhash) ^ (y * yhash) ^ (z * zhash), table_size);
}


uint mod(uint num, uint denom) {
    return num - ((uint)num / denom) * denom;
}