#pragma kernel make_map
#pragma kernel ray_trace


uint3 res;
float fov;
float3 origin;
uint num_particles;
float smoothing_rad;
float3 sun;
float rad;
float3 bounds;
float step_size;
float smooth_scale;
uint refracts;

RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> velocities;
RWBuffer<float> masses;
Buffer<float> densities;
Buffer<uint> part_map;
Buffer<uint> keys;
Buffer<uint> start_i;

RWTexture3D<float> dens_map;
RWTexture2D<float4> Result;


bool check(uint x, uint y, uint z, float xpos, float ypos, float zpos, float rad_sqr, uint3 id);
uint hash(uint x, uint y, uint z, uint table_size);
uint mod(uint num, uint denom);
float calc_dens(float3 pos);
float add_dens(uint x, uint y, uint z, float rad_sqr, float3 pos);
float smooth_kern(float dist, float rad);
float smooth_kern_deriv(float dist, float rad);
float3 refract_vector(float3 start, float n1, float n2, float3 pos);
float4 sample_env(float3 angle_vec);


[numthreads(8, 8, 16)]
void make_map(uint3 id : SV_DispatchThreadID) {
    dens_map[id] = calc_dens(id * step_size);
}


float calc_dens(float3 pos) {
    float dens = 0;
    float rad_sqr = smoothing_rad * smoothing_rad;
    int posx = (int)pos.x / smoothing_rad;
    int posy = (int)pos.y / smoothing_rad;
    int posz = (int)pos.z / smoothing_rad;
    int3 sres = int3((int)(bounds.x / smoothing_rad), (int)(bounds.y / smoothing_rad), (int)(bounds.z / smoothing_rad));

    for (int m = posx - 1; m < posx + 2; m++) {
        for (int n = posy - 1; n < posy + 2; n++) {
            for (int b = posz - 1; b < posz + 2; b++) {
                if (m >= 0 && n >= 0 && b >= 0 && m < sres.x && n < sres.y, b < sres.z) {
                    dens += add_dens((uint)m, (uint)n, (uint)b, rad_sqr, pos);
                }
            }
        }
    }

    return dens;
}


float add_dens(uint x, uint y, uint z, float rad_sqr, float3 pos) {
    uint key = hash(x, y, z, num_particles);
    float dens = 0;

    for (uint i = start_i[key]; i < num_particles && keys[i] == key; i++) {
        uint part_i = part_map[i];
        float3 diff = positions[part_i] - pos;
        float mag_sqr = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;
        if (mag_sqr == 0 || mag_sqr > rad_sqr) {
            continue;
        }
        dens += masses[part_i] * smooth_kern(sqrt(mag_sqr), smoothing_rad);
    }

    return dens;
}


float smooth_kern(float dist, float rad) {
    return dist < rad ? pow(rad - dist, 5) * 13.3690152197 / pow(rad, 8) * smooth_scale : 0;
}


[numthreads(32, 32, 1)]
void ray_trace(uint3 id : SV_DispatchThreadID) {
    float rad_sqr = rad * rad;
    float min_dens = 0.5;
    float water_i = 1.3;
    float air_i = 1.0;
    float rad_fov = radians(fov);
    float horz = sin(rad_fov) * (int)(id.x - ((res.x >> 1) + 1)) / res.x;
    float vert = sin(rad_fov * res.y / res.x) * (int)(id.y - ((res.y >> 1) + 1)) / res.y;
    float3 start = float3(horz, vert, 1.0) * rsqrt(horz * horz + vert * vert + 1);
    Result[id.xy] = sample_env(start);

    uint reps = (uint)(sqrt(bounds.x * bounds.x + bounds.y * bounds.y + bounds.z * bounds.z) + sqrt(origin.x * origin.x + origin.y * origin.y + origin.z * origin.z)) / step_size;
    float dens = 0;
    float3 ray_pos = origin;
    float4 env = sample_env(start);
    float blueness = 1.1;
    uint n;
    for (n = 0; n < refracts; n++) {
        for (uint i = 0; i < reps; i++) {
            ray_pos += start * step_size;
            if (ray_pos.x > 0 && ray_pos.y > 0 && ray_pos.z > 0 && ray_pos.x < bounds.x && ray_pos.y < bounds.y && ray_pos.z < bounds.z) {
                float new_dens = dens_map[(uint3)(ray_pos / step_size)];
                if ((new_dens > min_dens) != (dens > min_dens)) {
                    blueness *= 0.7;
                    start = refract_vector(start, new_dens > min_dens ? air_i : water_i, new_dens > min_dens ? water_i : air_i, ray_pos);
                    break;
                }
                dens = new_dens;
            } else if (n > 0) {
                break;
            }
        }
    }
    env = sample_env(start);
    env.xy *= blueness;
    Result[id.xy] = env;
}


float3 refract_vector(float3 start, float n1, float n2, float3 pos) {
    float rad_sqr = smoothing_rad * smoothing_rad;
    int posx = (int)pos.x / smoothing_rad;
    int posy = (int)pos.y / smoothing_rad;
    int posz = (int)pos.z / smoothing_rad;
    int3 sres = int3((int)(bounds.x / smoothing_rad), (int)(bounds.y / smoothing_rad), (int)(bounds.z / smoothing_rad));

    float3 normal = float3(0.0, 0.0, 0.0);
    for (int m = posx - 1; m < posx + 2; m++) {
        for (int n = posy - 1; n < posy + 2; n++) {
            for (int b = posz - 1; b < posz + 2; b++) {
                if (m >= 0 && n >= 0 && b >= 0 && m < sres.x && n < sres.y, b < sres.z) {
                    uint key = hash((uint)m, (uint)n, (uint)b, num_particles);
                    for (uint i = start_i[key]; i < num_particles && keys[i] == key; i++) {
                        float3 diff = pos - positions[part_map[i]];
                        float mag = diff.x * diff.x + diff.y * diff.y + diff.z * diff.z;
                        if (mag == 0.0 || mag > rad_sqr) {
                            continue;
                        }
                        mag = sqrt(mag);
                        normal += -(diff / mag) * smooth_kern_deriv(mag, smoothing_rad);
                    }
                }
            }
        }
    }
    normal = normalize(normal);
    if (dot(normal, start) > 1) {
        normal = -normal;
    }

    float fract = n1 / n2;
    float cthing = -dot(normal, start);

    float3 rangle = fract * (start + (cthing - sqrt(1 - fract * fract * (1 - cthing * cthing))) * normal);
    return dot(rangle, normal) > 0 ? start - (normal + normal) * dot(start, normal) : rangle;
}


float smooth_kern_deriv(float dist, float rad) {
    return dist < rad ? -pow(rad - dist, 4) / pow(rad, 8) : 0;
}


float4 sample_env(float3 angle_vec) {
    float4 ground = float4(0.5, 0.5, 0.5, 1.0);
    float4 zenith = float4(0.5, 0.5, 1.0, 1.0);
    float4 horizon = float4(0.9, 0.9, 1.0, 1.0);
    float horizon_dist = 5000.0;
    float half_pi = 1.571;
    // if (abs(angle_vec.x) < 0.01) {// || (angle_vec.z abs(angle_vec.y - angle_vec.z) < 10)) {
    //     return float4(1, 0, 0, 1.0);
    // }
    if (origin.y + angle_vec.y * horizon_dist < 0) {
        float dist = -origin.y / angle_vec.y;
        return ((((int)(dist * angle_vec.x) % 5) + ((int)(dist * angle_vec.z) % 5)) & 1) ? float4(1, 0, 0, 1.0) : float4(0, 1, 0, 1.0);
    }
    float neg_min_y = (float)origin.y / horizon_dist;
    float interp = 1 - (float)(angle_vec.y + neg_min_y) / (half_pi + neg_min_y);
    interp = pow(interp, 8);
    return horizon * interp + zenith * (1 - interp);
}


    // float xpos = origin.x - horz * origin.z;
    // float ypos = origin.y - vert * origin.z;
    // float zpos = smoothing_rad / 2;
    // int x = (int)(xpos / smoothing_rad);
    // int y = (int)(ypos / smoothing_rad);
    // int z = (int)(zpos / smoothing_rad);
    // int3 sres = int3((int)(res.x / smoothing_rad), (int)(res.y / smoothing_rad), (int)(res.z / smoothing_rad));

    
    // for (uint i = 0; i < num_particles; i++) {
    //     float3 postion = positions[i];
    //     float3 diff = origin - postion;
    //     float mid = dot(diff, start);
    //     float discrim = mid * mid + (rad * rad - dot(diff, diff));
    //     if (discrim > 0) {
    //         Result[id.xy] = float4(1.0, 1.0, 1.0, 1.0);
    //     }
    //     //     float3 intersect = origin + start * -(mid + sqrt(discrim));
    //     //     if (dot(intersect - origin, start) < 0) {
    //     //         continue;
    //     //     }
    //     //     float colour = 1.0 - abs(particles[i].velocity) / 4.0;
    //     //     Result[id.xy] = float4(1.0, colour, colour, 1.0);
    //     //     break;
    //     // }
    //     // float diffx = postion.x - xpos;
    //     // float diffy = postion.y - ypos;
    //     // if (diffx * diffx + diffy * diffy < rad_sqr) {
    //     //     Result[id.xy] = float4(1.0, 0.0, 0.0, 1.0);
    //     // }
    // }
    // int3 sres = int3((int)(res.x / smoothing_rad), (int)(res.y / smoothing_rad), (int)(res.z / smoothing_rad));
    // uint reps = (uint)(sqrt(bounds.x * bounds.x + bounds.y * bounds.y + bounds.z * bounds.z) + sqrt(origin.x * origin.x + origin.y * origin.y + origin.z * origin.z)) / smoothing_rad;
    // float3 marched = origin;
    // for (uint n = 0; n < reps; n++) {
    //     marched += start;
    //     if (marched.x < 0 || marched.y < 0 || marched.z < 0 || marched.x > bounds.x || marched.y > bounds.y || marched.z > bounds.z) {
    //         continue;
    //     }
    //     uint xpos = (uint)point.x / smoothing_rad;
    //     uint ypos = (uint)point.y / smoothing_rad;
    //     uint zpos = (uint)point.z / smoothing_rad;
    //     for (int b = 0; b < sres.z; b++) {
    //         for (int m = x - 1; m < x + 2; m++) {
    //             if (m >= 0 && n >= 0 && m < sres.x && n < sres.y) {
    //                 uint key = hash(b, ) 
    //                 float min_dist = -1.0;
    //                 for (uint i = 0; i < num_particles; i++) {
    //                     float3 postion = positions[i];
    //                     float3 diff = origin - postion;
    //                     // if (min_dist != -1.0 && (diff.z > min_dist || diff.x > min_dist || diff.y > min_dist)) {
    //                     //     continue;
    //                     // }
    //                     float mid = dot(diff, start);
    //                     float discrim = mid * mid + (rad_sqr - dot(diff, diff));
    //                     if (discrim > 0) {
    //                         float dist = -(mid + sqrt(discrim));
    //                         if (min_dist != -1.0 && dist > min_dist) {
    //                             continue;
    //                         }
    //                         float3 intersect = start * dist;
    //                         if (dot(intersect, start) < 0) {
    //                             continue;
    //                         }
    //                         min_dist = dist;
    //                         float3 normal = intersect + diff;
    //                         normal *= rsqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
    //                         Result[id.xy] = float4(0.0, 0.0, 1.0, 1.0) * (dot(sun, normal) + 1) / 2;
    //                     }
    //                 }
    //             }
    //         }
    //     }

    // }

    // for (int b = 0; b < sres.z; b++) {
    //     zpos += smoothing_rad;
    //     for (int m = x - 1; m < x + 2; m++) {
    //         for (int n = y - 1; n < y + 2; n++) {
    //             if (m >= 0 && n >= 0 && m < sres.x && n < sres.y) {
    //                 if(check((uint)m, (uint)n, (uint)b, start, rad_sqr, sun)) return;
    //             }
    //         }
    //     }
    // }


// bool check(uint x, uint y, uint z, float3 start, float rad_sqr, float3 sun) {
//     uint key = hash(x, y, z, num_particles);

//     for (uint i = start_i[key]; i < num_particles && keys[i] == key; i++) {
//         float3 postion = positions[part_map[i]];
//         float3 diff = origin - postion;
//         float mid = dot(diff, start);
//         float discrim = mid * mid + (rad_sqr - dot(diff, diff));
//         if (discrim > 0 && dot(intersect - origin, start) > 0) {
//             Result[id.xy] = float4(0.0, 0.0, 1.0, 1.0);
//             float3 intersect = origin + start * -(mid + sqrt(discrim));
//             float3 normal = intersect - postion;
//             Result[id.xy] *= (dot(sun, normal) + 1 ) / 2;
//             break;
//         }
//     }

//     return false;
// }


uint hash(uint x, uint y, uint z, uint table_size) {
    const uint xhash = 73856093;
    const uint yhash = 19349663;
    const uint zhash = 83492791;
    return mod((x * xhash) ^ (y * yhash) ^ (z * zhash), table_size);
}


uint mod(uint num, uint denom) {
    return num - ((uint)num / denom) * denom;
}